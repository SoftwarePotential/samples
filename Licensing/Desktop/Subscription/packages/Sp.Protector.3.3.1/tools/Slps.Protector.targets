<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup>
    <CustomBeforeSlpsProtectorTargets Condition="'$(CustomBeforeSlpsProtectorTargets)'==''">$(MSBuildExtensionsPath)\InishTech\Slps.Protector\Custom.Before.$(MSBuildThisFile)</CustomBeforeSlpsProtectorTargets>
    <CustomAfterSlpsProtectorTargets Condition="'$(CustomAfterSlpsProtectorTargets)'==''">$(MSBuildExtensionsPath)\InishTech\Slps.Protector\Custom.After.$(MSBuildThisFile)</CustomAfterSlpsProtectorTargets>
  </PropertyGroup>

  <Import Project="$(CustomBeforeSlpsProtectorTargets)" Condition="Exists('$(CustomBeforeSlpsProtectorTargets)')"/>

  <!--http://stackoverflow.com/a/5650767/11635-->
  <PropertyGroup>
    <_ProgramFilesX86Path Condition ="'$(_ProgramFilesX86Path)'==''">$(MSBuildProgramFiles32)</_ProgramFilesX86Path>
    <_ProgramFilesX86Path Condition ="'$(_ProgramFilesX86Path)'==''">$(ProgramFiles%28x86%29)</_ProgramFilesX86Path>
    <!-- Handle MSBuild 2.0/3.5 running in 64 bit mode; neither of the above env vars are available. 
		  NB Adding a literal " (x86)" to the 64 bit Program Files path may or may not work on all versions of Windows 
      See http://stackoverflow.com/questions/336633 -->
    <_ProgramFilesX86Path Condition ="'$(_ProgramFilesX86Path)'=='' AND 'AMD64' == '$(PROCESSOR_ARCHITECTURE)'">$(ProgramFiles) (x86)</_ProgramFilesX86Path>
    <_ProgramFilesX86Path Condition ="'$(_ProgramFilesX86Path)'==''">$(ProgramFiles)</_ProgramFilesX86Path>

    <SlpsSdkPath Condition="'$(SlpsSdkPath)'==''">$(_ProgramFilesX86Path)\InishTech SLP Code Protector</SlpsSdkPath>
  </PropertyGroup>

  <PropertyGroup>

    <SlpsProtectorTargetsImportedTwice Condition="$(SlpsProtectorTargetsImported)!=''">true</SlpsProtectorTargetsImportedTwice>
    <SlpsProtectorTargetsImported Condition="$(SlpsProtectorTargetsImported)==''">true</SlpsProtectorTargetsImported>

    <CompileDependsOn>
      _SpProtectTimestampBeforeCompile; <!-- Determine IntermediateAssembly status before compile -->
      $(CompileDependsOn);
      _SpProtectTimestampAfterCompile; <!-- Determine IntermediateAssembly status after compile -->

      SpProtectDetermineIfProtectionApplies; <!--Sets SpProtectProtectionApplies if we should protect and SpProtectAlreadyProtected if we already have protected IntermediateAssembly (to support incremental builds) -->
      SpProtectProbeForConfigurationFile; <!--Sets SpProtectConfigurationFilepath or raises an error-->

      SpProtect
    </CompileDependsOn>

    <CleanDependsOn>
      $(CleanDependsOn);
      SpProtectClean
    </CleanDependsOn>

    <SlpsSdkProtectorCmdIgnoreStandardErrorWarningFormat Condition=" '' == '$(SlpsSdkProtectorCmdIgnoreStandardErrorWarningFormat)' ">false</SlpsSdkProtectorCmdIgnoreStandardErrorWarningFormat>
    <SlpsSdkProtectorCmdFilepath Condition="'$(SlpsSdkProtectorCmdFilepath)'==''">$(SlpsSdkPath)\Microsoft.Licensing.ProtectCmd.exe</SlpsSdkProtectorCmdFilepath>
    <SlpsSdkProtectSnTool Condition="'$(SlpsSdkProtectSnTool)'==''">$(SlpsSdkPath)\ExternalTools\v2.0.50727\SN.exe</SlpsSdkProtectSnTool>

    <SlpsSdkImportanceLow Condition=" '' == '$(SlpsSdkImportanceLow)'">low</SlpsSdkImportanceLow>
    <SlpsSdkImportanceHigh Condition=" '' == '$(SlpsSdkImportanceHigh)'">high</SlpsSdkImportanceHigh>
    <SlpsSdkImportanceVeryHigh Condition=" '' == '$(SlpsSdkImportanceVeryHigh)'">high</SlpsSdkImportanceVeryHigh>

    <SpProtectAfterPath Condition="'$(SpProtectAfterPath)'==''">$(IntermediateOutputPath)SpProtect_After</SpProtectAfterPath>
    <SpProtectBeforePath Condition="'$(SpProtectBeforePath)'==''">$(IntermediateOutputPath)SpProtect_Before</SpProtectBeforePath>

    <SpConfigFileExtension>.SLMCfg</SpConfigFileExtension>

    <SpProtectDefineConstant Condition=" '' == '$(SpProtectDefineConstant)'">SLPS_PROTECT</SpProtectDefineConstant>
    <SpSkipProtectDefineConstant Condition=" '' == '$(SpSkipProtectDefineConstant)'">SKIP_SP_PROTECT</SpSkipProtectDefineConstant>

  </PropertyGroup>

  <Target Name="_SpProtectTimestampBeforeCompile">

    <CreateProperty Value="%(IntermediateAssembly.ModifiedTime)">
      <Output PropertyName="SpProtect_AssemblyTimestampBeforeCompile" TaskParameter="Value"/>
    </CreateProperty>

  </Target>

  <Target Name="_SpProtectTimestampAfterCompile">

    <CreateProperty Value="%(IntermediateAssembly.ModifiedTime)">
      <Output PropertyName="SpProtect_AssemblyTimestampAfterCompile" TaskParameter="Value"/>
    </CreateProperty>

  </Target>

  <Target Name="SpProtectDetermineIfProtectionApplies">

    <CreateItem Include="$(DefineConstants)">
      <Output TaskParameter="Include" ItemName="SpProtectDefineConstants_AsItems_ForBatching"/>
    </CreateItem>

    <CreateProperty
        Condition="'%(SpProtectDefineConstants_AsItems_ForBatching.Identity)'=='$(SpProtectDefineConstant)' AND '$(SpProtect_ProtectionRequestedViaDefine)'==''"
        Value="true">
      <Output PropertyName="SpProtect_ProtectionRequestedViaDefine" TaskParameter="Value" />
    </CreateProperty>
    <CreateProperty
        Condition="'%(SpProtectDefineConstants_AsItems_ForBatching.Identity)'=='$(SpSkipProtectDefineConstant)' AND '$(SpProtect_ProtectionRequestedViaDefine)'=='true'"
        Value="false">
      <Output PropertyName="SpProtect_ProtectionRequestedViaDefine" TaskParameter="Value" />
    </CreateProperty>
    <Message
        Condition="'$(SpProtect_ProtectionRequestedViaDefine)'!=''"
        Text="SpProtect_ProtectionRequestedViaDefine: $(SpProtect_ProtectionRequestedViaDefine)"
        Importance="$(SlpsSdkImportanceLow)"/>

    <Message
        Condition="('$(SpProtect_AssemblyTimestampBeforeCompile)'!='$(SpProtect_AssemblyTimestampAfterCompile)') And ('$(SpProtectAlreadyProtected)'=='false')"
        Text="Software Potential Protect Force Mode: Compile resulted in fresh assembly"
        Importance="high"/>

    <Message
        Condition="('$(SpProtect_AssemblyTimestampBeforeCompile)'=='$(SpProtect_AssemblyTimestampAfterCompile)') And ('$(SpProtectAlreadyProtected)'=='false')"
        Text="Software Potential Protect Force Mode: Compile did NOT update assembly"
        Importance="high"/>

    <CreateProperty
        Condition="('$(SpProtect_AssemblyTimestampBeforeCompile)'=='$(SpProtect_AssemblyTimestampAfterCompile)') And ('$(SpProtectAlreadyProtected)'=='')"
        Value="true">
      <Output PropertyName="SpProtectAlreadyProtected" TaskParameter="Value" />
    </CreateProperty>

    <Message
        Text="SpProtectAlreadyProtected: $(SpProtectAlreadyProtected) based on timestamps: Before=$(SpProtect_AssemblyTimestampBeforeCompile);After=$(SpProtect_AssemblyTimestampAfterCompile)"
        Importance="$(SlpsSdkImportanceLow)"/>

    <CreateProperty
        Condition=" 'true' == '$(SpProtect_ProtectionRequestedViaDefine)'"
        Value="true">
      <Output PropertyName="SpProtectProtectionApplies" TaskParameter="Value" />
    </CreateProperty>

    <!--If protection applies and we can skip it, post a notification-->
    <Message
      Condition="'$(SpProtectProtectionApplies)'=='true' AND '$(SpProtectAlreadyProtected)'=='true'"
      Importance="$(SlpsSdkImportanceHigh)"
      Text="Software Potential protection: Protection assumed to have been applied in previous build; compilation skipped this time hence skipping protection step"/>

  </Target>

  <Target
      Name="SpProtectProbeForConfigurationFile"
      Condition="'$(SpProtectProtectionApplies)'!=''">

    <CreateProperty
        Condition="
                '$(SpProtect_ProtectionRequestedViaDefine)'!=''
                AND '$(SpProtectConfigurationFilepath)'==''
                AND Exists('$(MSBuildProjectDirectory)\$(MSBuildProjectName).$(Configuration).$(Platform)$(SpConfigFileExtension)')"
        Value="$(MSBuildProjectDirectory)\$(MSBuildProjectName).$(Configuration).$(Platform)$(SpConfigFileExtension)">
      <Output PropertyName="SpProtectConfigurationFilepath" TaskParameter="Value" />
    </CreateProperty>

    <CreateProperty
        Condition="
                '$(SpProtect_ProtectionRequestedViaDefine)'!=''
                AND '$(SpProtectConfigurationFilepath)'==''
                AND Exists('$(MSBuildProjectDirectory)\$(MSBuildProjectName).$(Configuration)$(SpConfigFileExtension)')"
        Value="$(MSBuildProjectDirectory)\$(MSBuildProjectName).$(Configuration)$(SpConfigFileExtension)">
      <Output PropertyName="SpProtectConfigurationFilepath" TaskParameter="Value" />
    </CreateProperty>

    <CreateProperty
        Condition="
                '$(SpProtect_ProtectionRequestedViaDefine)'!=''
                AND '$(SpProtectConfigurationFilepath)'==''
                AND Exists('$(MSBuildProjectDirectory)\Sp.Protect.config')"
        Value="$(MSBuildProjectDirectory)\Sp.Protect.config">
      <Output PropertyName="SpProtectConfigurationFilepath" TaskParameter="Value" />
    </CreateProperty>

    <CreateProperty
        Condition="
                '$(SpProtect_ProtectionRequestedViaDefine)'!=''
                AND '$(SpProtectConfigurationFilepath)'==''
                AND Exists('$(MSBuildProjectDirectory)\$(MSBuildProjectName)$(SpConfigFileExtension)')"
        Value="$(MSBuildProjectDirectory)\$(MSBuildProjectName)$(SpConfigFileExtension)">
      <Output PropertyName="SpProtectConfigurationFilepath" TaskParameter="Value" />
    </CreateProperty>

    <Message
        Condition="!Exists('$(SpProtectConfigurationFilepath)')"
        Importance="$(SlpsSdkImportanceVeryHigh)"
        Text="$(SpProtectDefineConstant) Define specified for this build configuration but could not find configuration file in the project directory matching any of the following names:
    1) $(MSBuildProjectDirectory)\$(MSBuildProjectName).$(Configuration).$(Platform)$(SpConfigFileExtension)
    2) $(MSBuildProjectDirectory)\$(MSBuildProjectName).$(Configuration)$(SpConfigFileExtension)
    3) $(MSBuildProjectDirectory)\$(MSBuildProjectName)$(SpConfigFileExtension)
    4) $(MSBuildProjectDirectory)\Sp.Protect.config

The $(SpConfigFileExtension) file can be manually specified via either:
1) setting Property SpProtectConfigurationFilepath in e.g., $(MSBuildProjectFullPath) 
2) passing a value to MSBuild via e.g., /p:SpProtectConfigurationFilepath=&lt;path to config file$(SpConfigFileExtension)&gt;" />
    <Message
        Condition="'$(SpProtectConfigurationFilepath)'!=''"
        Text="SpProtectConfigurationFilepath: $(SpProtectConfigurationFilepath)"
        Importance="$(SlpsSdkImportanceLow)"/>

    <Error
        Condition="'$(SlpsProtectorTargetsImportedTwice)'!=''"
        Text="Slps.Protector: Imported Twice - Please ensure this does not occur by:
1) setting Slps_Protect_Disable_Auto to true if you're going to manually import Slps.Protector.targets
2) guarding all imports of Slps.Protector.targets with a Condition including '%24(SlpsProtectorTargetsImported)'==''"/>

  </Target>

  <PropertyGroup>
    <SpProtectDependsOn>
      PrepareSpProtect;
      BeforeSpProtect;
      CoreSpProtect;
      AfterSpProtect;
      OutputSpProtect;
    </SpProtectDependsOn>

  </PropertyGroup>


  <!--We only need to protect if the Protection is applicable for the project and we have no yet protected this IntermediateAssembly -->
  <Target
    Name="SpProtect"
    Condition="'$(SpProtectProtectionApplies)'!='' AND '$(SpProtectAlreadyProtected)'!='true'"
    DependsOnTargets="$(SpProtectDependsOn)"/>

  <!-- Copy @(IntermediateAssembly) and its .PDB into $(SpProtectBeforePath)-->
  <Target Name="PrepareSpProtect">

    <!--Compute path to IntermediateAssembly in SpProtectBeforePath -->
    <CreateItem Include="$(SpProtectBeforePath)\%(IntermediateAssembly.Filename)%(IntermediateAssembly.Extension)">
      <Output ItemName="SpProtectInputAssembly" TaskParameter="Include"/>
    </CreateItem>

    <CreateItem Include="$(SpProtectBeforePath)\$(TargetName).pdb">
      <Output ItemName="SpProtectInputAssemblyPdb" TaskParameter="Include"/>
    </CreateItem>

    <Copy
        SourceFiles="@(IntermediateAssembly)"
        DestinationFiles="@(SpProtectInputAssembly)"
        SkipUnchangedFiles="true"/>

    <Copy
        SourceFiles="$(IntermediateOutputPath)$(TargetName).pdb"
        DestinationFiles="@(SpProtectInputAssemblyPdb)"
        SkipUnchangedFiles="true"
        Condition="Exists('$(IntermediateOutputPath)$(TargetName).pdb')"/>

    <!--We also create Items for the paths to the protected output assemblies, even though they do not yet exist-->
    <CreateItem Include="$(SpProtectAfterPath)\%(IntermediateAssembly.Filename)%(IntermediateAssembly.Extension)">
      <Output ItemName="SpProtectOutputAssembly" TaskParameter="Include"/>
    </CreateItem>

    <CreateItem Include="$(SpProtectAfterPath)\$(TargetName).pdb">
      <Output ItemName="SpProtectOutputAssemblyPdb" TaskParameter="Include"/>
    </CreateItem>

  </Target>

  <!-- Override this target for custom behavior. The assembly before protection is in $(SpProtectBeforePath) as @(SpProtectInputAssembly) -->
  <Target Name="BeforeSpProtect"></Target>

  <!-- Override this target for custom behavior. The assembly after protection is in $(SpProtectAfterPath) as @(SpProtectOutputAssembly) -->
  <Target Name="AfterSpProtect"></Target>

  <Target Name="OutputSpProtect">

    <!--Copy the main assembly and updated .PDB from After to IntermediateOutputPath (i.e., replace the compiler output with the protected assembly)-->
    <Copy
      SourceFiles="@(SpProtectOutputAssembly)"
      DestinationFolder="$(IntermediateOutputPath)"/>
    <Copy
      Condition="EXISTS('@(SpProtectOutputAssemblyPdb)')"
      SourceFiles="@(SpProtectOutputAssemblyPdb)"
      DestinationFolder="$(IntermediateOutputPath)"/>

    <!--Compute an itemlist of runtime outputs added by the protection-->
    <CreateItem Include="$(SpProtectAfterPath)\**\*" Exclude="$(SpProtectAfterPath)\%(IntermediateAssembly.Filename).*">
      <Output ItemName="SpProtectInducedIntermediates" TaskParameter="Include"/>
    </CreateItem>

    <!--Pass the runtimes directly into the output path (not into the intermediate path), e.g., \bin\debug, not \obj\debug.
	The files will already be there if build didn't touch the intermediate assembly-->
    <Copy
        SourceFiles="@(SpProtectInducedIntermediates)"
        DestinationFiles="@(SpProtectInducedIntermediates->'$(OutDir)\%(RecursiveDir)%(Filename)%(Extension)')"
        SkipUnchangedFiles="true"/>

    <!--We're not sure if the DestinationFiles output param of Copy task will exclude files that were skipped because of a SkipUnchangedFiles=true-->
    <CreateItem Include="@(SpProtectInducedIntermediates->'$(OutDir)\%(RecursiveDir)%(Filename)%(Extension)')">
      <Output ItemName="SpProtectInducedOutputs" TaskParameter="Include"/>
    </CreateItem>

    <Message
        Importance="$(SlpsSdkImportanceVeryHigh)"
        Text="$(MSBuildProjectName) -&gt; %(SpProtectInducedOutputs.FullPath) (added by Software Potential Protection)"/>

  </Target>

  <PropertyGroup>
    <CoreSpProtectDependsOn>
      SpRunProtectCmd;
      SpProtectResignAfterProtect;
    </CoreSpProtectDependsOn>
  </PropertyGroup>
  <Target Name="CoreSpProtect" DependsOnTargets="$(CoreSpProtectDependsOn)"/>

  <Target Name="SpRunProtectCmd">
    <!-- TODO, add equivalent of Inputs="@(SpProtectConfigurationFilepath)" so touching it forces a recompile -->

    <Error
        Condition="!Exists('$(SpProtectConfigurationFilepath)')"
        Text="Could not find configuration file specified via property SpProtectConfigurationFilepath: $(SpProtectConfigurationFilepath)"/>

    <CreateItem Include="@(_ResolveAssemblyReferenceResolvedFiles->'%(RootDir)%(Directory)')">
      <Output TaskParameter="Include" ItemName="SpProtectRefPaths" />
    </CreateItem>

    <CreateItem Include="%(SpProtectRefPaths.Identity)">
      <Output TaskParameter="Include" ItemName="SpProtectRefPaths_NoDups" />
    </CreateItem>

    <CreateProperty Value="@(SpProtectRefPaths_NoDups)">
      <Output TaskParameter="Value" PropertyName="SpProtectRefPaths_NoDups_Property" />
    </CreateProperty>

    <!--We need to create to make a proeprty of this item group to work around an MSBuild issue-->
    <CreateProperty Value="@(SpProtectInputAssembly)">
      <Output TaskParameter="Value" PropertyName="SpProtectInputAssemblyProperty" />
    </CreateProperty>

    <CreateProperty
        Condition="'$(SpProtectSubstitutionsSkip)'==''"
        Value="$(SpProtect_Substitutions_Before),Global/InputDir=$(SpProtectBeforePath),ProtectedAssembly/SkipResign=true,ProtectedAssembly/ModuleName=$(SpProtectInputAssemblyProperty),Global/ReferencePaths={0};$(SpProtectRefPaths_NoDups_Property),Global/OutputDir=$(SpProtectAfterPath),$(SpProtect_Substitutions_After)">
      <Output PropertyName="SpProtectSubstitutionsToUse" TaskParameter="Value"/>
    </CreateProperty>

    <Message
          Text="SpProtectSubstitutionsToUse: $(SpProtectSubstitutionsToUse)"
          Importance="$(SlpsSdkImportanceLow)"/>

    <!-- Remove intermediate output prior to protection as its presence is in effect a flag that the build succeeded and we don't want to leave people with an unprotected file when they retry -->
    <!-- Would use move above to remove this step, but want single code base across all MsBuild versions -->
    <Delete Files="@(IntermediateAssembly)"/>
    <RemoveDir Directories="$(SpProtectAfterPath)"/>
    <Exec IgnoreStandardErrorWarningFormat="$(SlpsSdkProtectorCmdIgnoreStandardErrorWarningFormat)" Command="&quot;$(SlpsSdkProtectorCmdFilepath)&quot; &quot;$(SpProtectConfigurationFilepath)&quot; &quot;$(SpProtectSubstitutionsToUse)&quot;"/>

  </Target>

  <Target Name="SpProtectResignAfterProtect" Condition="$(SignAssembly) == 'true'">
    <!--We resign only when the original compile signed the assembly (SignAssembly is from Microsoft.Common.Targets)-->
    <!--ResolveKeySources from Microsoft.Common.Targets will populate KeyContainerName in case the key is from a password-protected PFX file, whic we then have to use. Else fall back to KeyOriginatorFile-->
    <Exec Condition=" '$(KeyContainerName)' != '' " Command="&quot;$(SlpsSdkProtectSnTool)&quot; -Rca &quot;@(SpProtectOutputAssembly)&quot; &quot;$(KeyContainerName)&quot; " />
    <Exec Condition=" '$(KeyContainerName)' == '' " Command="&quot;$(SlpsSdkProtectSnTool)&quot; -Ra &quot;@(SpProtectOutputAssembly)&quot; &quot;$(KeyOriginatorFile)&quot; " />
  </Target>

  <Target Name="SpProtectClean">

    <Message
        Importance="$(SlpsSdkImportanceLow)"
        Text="Cleaning $(SpProtectBeforePath);$(SpProtectAfterPath);" />
    <RemoveDir Directories="$(SpProtectBeforePath);$(SpProtectAfterPath)" ContinueOnError="true"/>

  </Target>

  <Import Project="$(CustomAfterSlpsProtectorTargets)" Condition="Exists('$(CustomAfterSlpsProtectorTargets)')"/>

</Project>
